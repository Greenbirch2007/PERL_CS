use strict;
use warnings;
use DBI;

open( my $HOSTS, '<', '/etc/hosts' ) or die "Unable to open host file:$!\n";
my %addrs;
my %names;
while ( defined( $_ = <$HOSTS> ) ) {
    next if /^#/; # skip comments lines
    next if /^\s*$/; # skip empty lines
    s/\s*#.*$//; # delete in-line comments and preceding whitespace
    chomp;
    my ( $ip, @names ) = split;
    die "The IP address $ip already seen!\n" if ( exists $addrs{$ip} );
    $addrs{$ip} = [@names];
    for (@names) {
        die "The host name $_ already seen!\n" if ( exists $names{lc $_} );
        $names{lc $_} = $ip;
    }
}
close $HOSTS;

$addrs{'127.0.0.1'} = ['localhost'];
$addrs{'192.168.1.2'} = ['rivendell.oog.org','rivendell'];
$addrs{'192.168.1.1'} = ['everest.oog.org','everest'];
$names{'localhost'} = '127.0.0.1';
$names{'everest'} = '192.168.1.1';
$names{'everest.oog.org'} = '192.168.1.1';
$names{'rivendell'} = '192.168.1.2';
$names{'rivendell.oog.org'} = '192.168.1.2';



my $datafile = 'database';
my $recordsep = "-=-\n";
open my $DATAFILE, '<', "$datafile" or die "Unable to open datafile:$!\n";
{
    local $/ =
        $recordsep; # prepare to read in database file one record at a time
    print "#\n# host file - GENERATED BY $0\n# DO NOT EDIT BY HAND!\n#\n";
    my %record;
    while (<$DATAFILE>) {
        chomp; # remove the record separator
        # split into key1,value1,...bingo, hash of record
        %record = split /:\s*|\n/;
        print "$record{address}\t$record{name} $record{aliases}\n";
    }
    close $DATAFILE;
}

my $datafile = 'database';
my $recordsep = "-=-\n";
open my $DATAFILE, '<', "$datafile" or die "Unable to open datafile:$!\n";
{
    local $/ =
        $recordsep; # prepare to read in database file one record at a time
    print "#\n# host file - GENERATED BY $0\n# DO NOT EDIT BY HAND!\n#\n";
    my %record;
    my %addrs;
    while (<$DATAFILE>) {
        chomp; # remove the record separator
        # split into key1,value1,... bingo, hash of record
        %record = split /:\s*|\n/;
        # check for bad hostnames
        if ( $record{name} =~ /[^-.a-zA-Z0-9]/ ) {
            warn "!!!! $record{name} has illegal host name characters, "
                . "skipping...\n";
            next;
        }# check for bad aliases
        if ( $record{aliases} =~ /[^-.a-zA-Z0-9\s]/ ) {
            warn "!!!! $record{name} has illegal alias name characters, "
                . "skipping...\n";
            next;
        }
        # check for missing address
        if ( !$record{address} ) {
            warn "!!!! $record{name} does not have an IP address, "
                . "skipping...\n";
            next;
        }
        # check for duplicate address
        if ( defined $addrs{ $record{address} } ) {
            warn "!!!! Duplicate IP addr: $record{name} &
 $addrs{$record{address}}, skipping...\n";
            next;
        }
        else {
            $addrs{ $record{address} } = $record{name};
        }
        print "$record{address}\t$record{name} $record{aliases}\n";
    }
    close $DATAFILE;
}

my $datafile = 'database';
my $recordsep = "-=-\n";
# get username on either Windows or Unix
my $user =
    ( $^O eq 'MSWin32' ) ? $ENV{USERNAME} :
        (getpwuid($<))[6] . ' (' . (getpwuid($<))[0] . ')';
open my $DATAFILE, '<', "$datafile" or die "Unable to open datafile:$!\n";
my %addrs;
my %entries;
{
    local $/ = $recordsep; # read in database file one record at a time
    while (<$DATAFILE>) {
        chomp; # remove the record separator
        # split into key1,value1
        my @record = split /:\s*|\n/;
        my $record = {}; # create a reference to empty hash
        %{$record} = @record; # populate that hash with @record
        # check for bad hostname
        if ( $record->{name} =~ /[^-.a-zA-Z0-9]/ ) {
            warn '!!!! '
                . $record->{name}
                . " has illegal host name characters, skipping...\n";
            next;
        }
        # check for bad aliases
        if ( $record->{aliases} =~ /[^-.a-zA-Z0-9\s]/ ) {
            warn '!!!! '
                . $record->{name}
                . " has illegal alias name characters, skipping...\n";
            next;
        }
        # check for missing address
        if ( !$record->{address} ) {
            warn '!!!! '
                . $record->{name}
                . " does not have an IP address, skipping...\n";
            next;
        }# check for duplicate address
        if ( defined $addrs{ $record->{address} } ) {
            warn '!!!! Duplicate IP addr:'
                . $record->{name} . ' & '
                . $addrs{ $record->{address} }
                . ", skipping...\n";
            next;
        }
        else {
            $addrs{ $record->{address} } = $record->{name};
        }
        $entries{ $record->{name} } = $record; # add this to a hash of hashes
    }
    close $DATAFILE;
}

# print a nice header
print "#\n# host file - GENERATED BY $0\n# DO NOT EDIT BY HAND!\n#\n";
print "# Converted by $user on " . scalar(localtime) . "\n#\n";
# count the number of entries in each department and then report on it
my %depts;
foreach my $entry ( keys %entries ) {
    $depts{ $entries{$entry}->{department} }++;
}
foreach my $dept ( keys %depts ) {
    print "# number of hosts in the $dept department: $depts{$dept}.\n";
}
print '# total number of hosts: ' . scalar( keys %entries ) . "\n#\n\n";
# iterate through the hosts, printing a nice comment and the entry itself
foreach my $entry ( keys %entries ) {
    print '# Owned by ', $entries{$entry}->{owner}, ' (',
        $entries{$entry}->{department}, "): ", $entries{$entry}->{building}, '/',
        $entries{$entry}->{room}, "\n";
    print $entries{$entry}->{address}, "\t", $entries{$entry}->{name}, ' ',
        $entries{$entry}->{aliases}, "\n\n";
}

sub byaddress {
    my @a = split(/\./,$entries{$a}->{address});
    my @b = split(/\./,$entries{$b}->{address});
    ($a[0]<=>$b[0]) ||
        ($a[1]<=>$b[1]) ||
        ($a[2]<=>$b[2]) ||
        ($a[3]<=>$b[3]);
}

my $outputfile = "hosts.$$"; # temporary output file
my $target = 'hosts'; # where we want the converted data stored
...
open my $OUTPUT, '>', "$outputfile" or
    die "Unable to write to $outputfile:$!\n";
print $OUTPUT "#\n# host file - GENERATED BY $0\n# DO NOT EDIT BY HAND!\n#\n";

print $OUTPUT "# Converted by $user on " . scalar(localtime) . "\n#\n";
...
foreach my $dept ( keys %depts ) {
    print $OUTPUT "# number of hosts in the $dept department: $depts{$dept}.\n";
}
print $OUTPUT '# total number of hosts: ' . scalar( keys %entries ) . "\n#\n\n";
# iterate through the hosts, printing a nice comment and the entry itself
foreach my $entry ( keys %entries ) {
    print $OUTPUT '# Owned by ', $entries{$entry}->{owner}, ' (',
        $entries{$entry}->{department}, '): ', $entries{$entry}->{building}, '/',
        $entries{$entry}->{room}, "\n";
    print $OUTPUT $entries{$entry}->{address}, "\t", $entries{$entry}->{name},
        ' ', $entries{$entry}->{aliases}, "\n\n";
}
close $OUTPUT;
use Rcs;
Rcs->bindir('/arch/gnu/bin');
my $rcsobj = Rcs->new;
$rcsobj->file($target);
$rcsobj->co('-l');
rename( $outputfile, $target )
    or die "Unable to rename $outputfile to $target:$!\n";
$rcsobj->ci( '-u',
    '-m'
        . 'Converted by '
        . ( getpwuid($<) )[6] . ' ('
        . ( getpwuid($<) )[0] . ') on '
        . scalar localtime );
use Net::NIS;

# get our default NIS domain name
my $domain = Net::NIS::yp_get_default_domain();
# grab the map
my ( $status, $info ) = Net::NIS::yp_all( $domain, 'hosts.byname' );
foreach my $name ( sort keys %{$info} ) {
    print "$name => $info->{$name}\n";
}

use Net::NIS;
my $hostname = 'olaf.oog.org';
my $domain = Net::NIS::yp_get_default_domain();
my ( $status, $info ) =
    Net::NIS::yp_match( $domain, 'hosts.byname', $hostname );
print "$info\n";

use Net::NIS;
my $yppollex = '/usr/sbin/yppoll'; # full path to the yppoll executable
my $domain = Net::NIS::yp_get_default_domain(); # our NIS domain
my ( $status, $info ) = Net::NIS::yp_all( $domain, 'ypservers' );
foreach my $server ( sort keys %{$info} ) {
    my $answer = `$yppollex -h $server hosts.byname`;
    if ( $answer !~ /has order number/ ) {
        print STDERR "$server is not responding properly!\n";
    }
}


# get today's date in the form of YYYYMMDD
my @localtime = localtime;
my $today = sprintf( "%04d%02d%02d",
    $localtime[5] + 1900,
    $localtime[4] + 1,
    $localtime[3] );
# get username on either Windows or Unix
my $user =
    ( $^O eq 'MSWin32' )
        ? $ENV{USERNAME}
        : ( getpwuid($<) )[6] . ' (' . ( getpwuid($<) )[0] . ')';
sub GenerateHeader {
    my ($olddate,$count);
    # open old file if possible and read in serial number
    # (assumes the format of the old file)
    if ( open( my $OLDZONE, '<', $target ) ) {
        while (<$OLDZONE>) {
            last if ( $olddate, $count ) = /(\d{8})(\d{2}).*serial/;
        }
        close $OLDZONE;
    }
    # If $count is defined, we did find an old serial number.
    # If the old serial number was for today, increment last 2 digits;
    # else start a new number for today.
    my $count = ( defined $count and $olddate eq $today ) ? $count + 1 : 0;
    my $serial = sprintf( "%8d%02d", $today, $count );
    # begin the header
    my $header = "; dns zone file - GENERATED BY $0\n";
    $header .= "; DO NOT EDIT BY HAND!\n;\n";
    $header .= "; Converted by $user on " . scalar( (localtime) ) . "\n;\n";
    # count the number of entries in each department and then report
    foreach my $entry ( keys %entries ) {
        $depts{ $entries{$entry}->{department} }++;
    }
    foreach my $dept ( keys %depts ) {
        $header .=
            "; number of hosts in the $dept department: " . "$depts{$dept}.\n";
    }
    $header .=
        '; total number of hosts: ' . scalar( keys %entries ) . "\n;\n\n";
    $header .= <<"EOH";
@ IN SOA dns.oog.org. hostmaster.oog.org. (
 $serial ; serial
 10800 ; refresh
 3600 ; retry
 604800 ; expire
 43200) ; TTL
@ IN NS dns.oog.org.
EOH
    return $header;
}
use Rcs;
my $datafile = 'database'; # our host database
my $outputfile = "zone.$$"; # our temporary output file
my $target = 'zone.db'; # our target output
my $revtarget = 'rev.db'; # our target output for the reverse mapping
my $defzone = '.oog.org'; # the default zone being created
my $rcsbin = '/usr/local/bin'; # location of our RCS binaries
my $recordsep = "-=-\n";
# get today's date in the form YYYYMMDD
my @localtime = localtime;
my $today = sprintf( "%04d%02d%02d",
    $localtime[5] + 1900,
    $localtime[4] + 1,
    $localtime[3] );
# get username on either Windows or Unix
my $user = ( $^O eq 'MSWin32' )
    ? $ENV{USERNAME}
    : ( getpwuid($<) )[6] . ' (' . ( getpwuid($<) )[0] . ')';
# read in the database file
open my $DATAFILE, '<', "$datafile" or die "Unable to open datafile:$!\n";
my %addrs;
my %entries;
{
    local $/ = $recordsep; # read in the database file one record at a time
    while (<$DATAFILE>) {
        chomp; # remove the record separator
        # split into key1,value1
        my @record = split /:\s*|\n/;
        my $record = {}; # create a reference to empty hash
        %{$record} = @record; # populate that hash with @record
        # check for bad hostname
        if ( $record->{name} =~ /[^-.a-zA-Z0-9]/ ) {
            warn '!!!! '
                . $record->{name}
                . " has illegal host name characters, skipping...\n";
            next;
        }
        # check for bad aliases
        if ( $record->{aliases} =~ /[^-.a-zA-Z0-9\s]/ ) {
            warn '!!!! '
                . $record->{name}
                . " has illegal alias name characters, skipping...\n";
            next;
        }
        # check for missing address
        if ( !$record->{address} ) {
            warn '!!!! '
                . $record->{name}
                . " does not have an IP address, skipping...\n";
            next;
        }
        # check for duplicate address
        if ( defined $addrs{ $record->{address} } ) {
            warn '!!!! Duplicate IP addr:'
                . $record->{name} . ' & '
                . $addrs{ $record->{address} }
                . ", skipping...\n";
            next;
        }
        else {
            $addrs{ $record->{address} } = $record->{name};
        } $entries{ $record->{name} } = $record; # add this to a hash of hashes
    }
    close $DATAFILE;
}
my $header = GenerateHeader();
# create the forward mapping file
open my $OUTPUT, '>', "$outputfile"
    or die "Unable to write to $outputfile:$!\n";
print $OUTPUT $header;
foreach my $entry ( sort byaddress keys %entries ) {
    print $OUTPUT "; Owned by ", $entries{$entry}->{owner}, ' (',
        $entries{$entry}->{department}, "): ", $entries{$entry}->{building}, '/',
        $entries{$entry}->{room}, "\n";
    # print A record
    printf $OUTPUT "%-20s\tIN A %s\n", $entries{$entry}->{name},
        $entries{$entry}->{address};
    # print any CNAMES (aliases)
    if ( defined $entries{$entry}->{aliases} ) {
        foreach my $alias ( split( ' ', $entries{$entry}->{aliases} ) ) {
            printf $OUTPUT "%-20s\tIN CNAME %s\n", $alias,
                $entries{$entry}->{name};
        }
    }
    print $OUTPUT "\n";
}
close $OUTPUT;
Rcs->bindir($rcsbin);
my $rcsobj = Rcs->new;
$rcsobj->file($target);
$rcsobj->co('-l');
rename( $outputfile, $target )
    or die "Unable to rename $outputfile to $target:$!\n";
$rcsobj->ci( '-u', '-m' . "Converted by $user on " . scalar(localtime) );
# now create the reverse mapping file
open my $OUTPUT, '>', "$outputfile"
    or die "Unable to write to $outputfile:$!\n";
print $OUTPUT $header;
foreach my $entry ( sort byaddress keys %entries ) {
    print $OUTPUT '; Owned by ', $entries{$entry}->{owner}, ' (',
        $entries{$entry}->{department}, '): ', $entries{$entry}->{building}, '/',
        $entries{$entry}->{room}, "\n";
    # this uses the default zone we defined at the start of the script
    printf $OUTPUT "%-3d\tIN PTR %s$defzone.\n\n",
        ( split /\./, $entries{$entry}->{address} )[3], $entries{$entry}->{name};
}
close $OUTPUT;
$rcsobj->file($revtarget);
$rcsobj->co('-l'); # assumes target has been checked out at least once
rename( $outputfile, $revtarget )
    or die "Unable to rename $outputfile to $revtarget:$!\n";
$rcsobj->ci( "-u", "-m" . "Converted by $user on " . scalar(localtime) );
sub GenerateHeader {
    my ( $olddate, $count );
    # open old file if possible and read in serial number
    # (assumes the format of the old file)
    if ( open( my $OLDZONE, '<', $target ) ) {
        while (<$OLDZONE>) {
            last if ( $olddate, $count ) = /(\d{8})(\d{2}).*serial/;
        }
        close $OLDZONE;
    }
    # If $count is defined, we did find an old serial number.
    # If the old serial number was for today, increment last 2 digits;
    # else start a new number for today.
    my $count = ( defined $count and $olddate eq $today ) ? $count + 1 : 0;
    my $serial = sprintf( "%8d%02d", $today, $count );
    # begin the header
    my $header = "; dns zone file - GENERATED BY $0\n";
    $header .= "; DO NOT EDIT BY HAND!\n;\n";
    $header .= "; Converted by $user on " . scalar( (localtime) ) . "\n;\n";
    # count the number of entries in each department and then report
    my %depts;
    foreach my $entry ( keys %entries ) {
        $depts{ $entries{$entry}->{department} }++;
    }
    foreach my $dept ( keys %depts ) {
        $header .=
            "; number of hosts in the $dept department: " . "$depts{$dept}.\n";
    }
    $header .=
        '; total number of hosts: ' . scalar( keys %entries ) . "\n;\n\n";
    $header .= <<"EOH";
EOH
    return $header;
}
sub byaddress {
    my @a = split( /\./, $entries{$a}->{address} );
    my @b = split( /\./, $entries{$b}->{address} );
    ( $a[0] <=> $b[0] )
        || ( $a[1] <=> $b[1] )
        || ( $a[2] <=> $b[2] )
        || ( $a[3] <=> $b[3] );
}
use Data::Dumper;
my $hostname = $ARGV[0];
my @servers = qw(nameserver1 nameserver2 nameserver3); # name servers
my %results;
foreach my $server (@servers) {
    $results{$server}
        = LookupAddress( $hostname, $server ); # populates %results
}
my %inv = reverse %results; # invert the result hash
if (scalar keys %inv > 1) { # see how many elements it has
    print "There is a discrepancy between DNS servers:\n";
    print Data::Dumper->Dump( [ \%results ], ['results'] ), "\n";
}

$results = {
    nameserver1 => '192.168.1.2',
    nameserver2 => '192.168.1.5',
    nameserver3 => '192.168.1.2',
};


use Data::Dumper;
my $hostname = $ARGV[0];
my @servers = qw(nameserver1 nameserver2 nameserver3 nameserver4);
my $nslookup = '/usr/bin/nslookup';
my %results;
foreach my $server (@servers) {
    $results{$server}
        = LookupAddress( $hostname, $server ); # populates %results
}
my %inv = reverse %results; # invert the result hash
if ( scalar keys %inv > 1 ) { # see how many elements it has
    print "There is a discrepency between DNS servers:\n";
    print Data::Dumper->Dump( [ \%results ], ['results'] ), "\n";
}
sub LookupAddress {
    my ( $hostname, $server ) = @_;
    my @results;
    open my $NSLOOK, '-|', "$nslookup $hostname $server"
        or die "Unable to start nslookup:$!\n";
    while (<$NSLOOK>) {
        next until (/^Name:/); # ignore until we hit "Name: "
        chomp( $result = <$NSLOOK> ); # next line is Address: response
        $result =~ s/Address(es)?:\s+//; # remove the label
        push( @results, $result );
    }
    close $NSLOOK;
    return join( ', ', sort @results );
}
use IO::Socket;
use Data::Dumper;
my $hostname = $ARGV[0];
my @servers = qw(nameserver1 nameserver2 nameserver3); # name of the name servers
my $defdomain = '.oog.org'; # default domain if not present
my %results;
foreach my $server (@servers) {
    $results{$server}
        = LookupAddress( $hostname, $server ); # populates %results
}
my %inv = reverse %results; # invert the result hash
if ( scalar keys %inv > 1 ) { # see how many elements it has
    print "There is a discrepency between DNS servers:\n";
    print Data::Dumper->Dump( [ \%results ], ['results'] ), "\n";
}
sub LookupAddress {
    my ( $hostname, $server ) = @_;
    my $id = 0;
    my ( $lformat, @labels, $count, $buf );

    ###
    ### Construct the packet header
    ###
    my $header = pack(
        'n C2 n4',
        ++$id, # query id
        1, # qr, opcode, aa, tc, rd fields (only rd set)
        0, # ra, z, rcode
        1, # one question (qdcount)
        0, # no answers (ancount)
        0, # no ns records in authority section (nscount)
        0
    ); # no additional rr's (arcount)
    # if we do not have any separators in the name of the host,
    # append the default domain
    if ( index( $hostname, '.' ) == −1 ) {
        $hostname .= $defdomain;
    }
    # construct the qname section of a packet (domain name in question)
    for ( split( /\./, $hostname ) ) {
        $lformat .= 'C a* ';
        $labels[ $count++ ] = length;
        $labels[ $count++ ] = $_;
    }
    ###
    ### construct the packet question section
    ###
    my $question = pack(
        $lformat . 'C n2',
        @labels,
        0, # end of labels
        1, # qtype of A
        1
    ); # qclass of IN
    ###
    ### send the packet to the server and read the response
    ###
    my $sock = new IO::Socket::INET(
        PeerAddr => $server,
        PeerPort => 'domain',
        Proto => 'udp'
    );
    $sock->send( $header . $question );
    # we know the max packet size
    $sock->recv( $buf, 512 );
    close($sock);
###
### unpack the header section
    ###
    my ( $id, $qr_opcode_aa_tc_rd, $ra_z_rcode, $qdcount, $ancount, $nscount,
        $arcount )
        = unpack( 'n C2 n4', $buf );
    if ( !$ancount ) {
        warn "Unable to lookup data for $hostname from $server!\n";
        return;
    }
    ###
    ### unpack the question section
    ###
    # question section starts 12 bytes in
    my ( $position, $qname ) = decompress( $buf, 12 );
    my ( $qtype, $qclass ) = unpack( '@' . $position . 'n2', $buf );
    # move us forward in the packet to end of question section
    $position += 4;
    ###
    ### unpack all of the resource record sections
    ###
    my ( $rtype, $rclass, $rttl, $rdlength, $rname, @results );
    for ( ; $ancount; $ancount-- ) {
        ( $position, $rname ) = decompress( $buf, $position );
        ( $rtype, $rclass, $rttl, $rdlength )
            = unpack( '@' . $position . 'n2 N n', $buf );
        $position += 10;
        # this next line could be changed to use a more sophisticated
        # data structure - it currently concatenates all of the answers
        push( @results,
            join( '.', unpack( '@' . $position . 'C' . $rdlength, $buf ) ) );
        $position += $rdlength;
    }
    # we sort results to deal with round-robin DNS responses
    #
    # we probably should use a custom sort routine to sort
    # them semantically, but in this case we're just looking for
    # the presence of different results from each DNS server
    return join( ', ', sort @results );
}
# handle domain information that is "compressed" as per RFC 1035
#
# we take in the starting position of our packet parse and return
# the place in the packet we left off at the end of the domain name
# (after dealing with the compressed format pointer) and the name we found
sub decompress {
    my ( $buf, $start ) = @_;
    my ( $domain, $i, $lenoct );
    # get the size of the response, since we're going to have to keep track of
    # where we are in that data
    my $respsize = length($buf);
    for ( $i = $start; $i <= $respsize; ) {
        $lenoct = unpack( '@' . $i . 'C', $buf ); # get length of label
        if ( !$lenoct ) { # 0 signals we are done with this section
            $i++;
            last;
        }
        if ( $lenoct == 192 ) { # we've been handed a pointer, so recurse
            $domain .= (
                decompress(
                    $buf, ( unpack( '@' . $i . 'n', $buf ) & 1023 )
                )
            )[1];
            $i += 2;
            last;
        }
        else { # otherwise, we have a plain label
            $domain .= unpack( '@' . ++$i . 'a' . $lenoct, $buf ) . '.';
            $i += $lenoct;
        }
    }
    return ( $i, $domain );
}



use Net::DNS;
my $hostname = $ARGV[0];
my @servers = qw(nameserver1 nameserver2 nameserver3 nameserver4);
my %results;
foreach my $server (@servers) {
    $results{$server}
        = LookupAddress( $hostname, $server ); # populates %results
}
my %inv = reverse %results; # invert the result hash
if ( scalar keys %inv > 1 ) { # see how many elements it has
    print "There is a discrepency between DNS servers:\n";
    use Data::Dumper;
    print Data::Dumper->Dump( [ \%results ], ['results'] ), "\n";
}
# only slightly modified from the example in the Net::DNS manpage
sub LookupAddress {
    my ( $hostname, $server ) = @_;
    my $res = new Net::DNS::Resolver;
    $res->nameservers($server);
    my $packet = $res->query($hostname);
    if ( !$packet ) {
        warn "Unable to lookup data for $hostname from $server!\n";
        return;
    }
    my (@results);
    foreach my $rr ( $packet->answer ) {
        push( @results, $rr->address );
    }
    return join( ', ', sort @results );
}

use IO::Socket::INET;
use Net::DHCP::Packet;
use Net::DHCP::Constants;
my $br_addr = sockaddr_in( '67', inet_aton('255.255.255.255') );
my $xid = int( rand(0xFFFFFFFF) );
my $chaddr = '0016cbb7c882';
my $socket = IO::Socket::INET->new(
    Proto => 'udp',
    Broadcast => 1,
    LocalPort => '68',
) or die "Can't create socket: $@\n";
my $discover_packet = Net::DHCP::Packet->new(
    Xid => $xid,
    Chaddr => $chaddr,
    Flags => 0x8000,
    DHO_DHCP_MESSAGE_TYPE() => DHCPDISCOVER(),
    DHO_HOST_NAME() => 'Perl Test Client',
    DHO_VENDOR_CLASS_IDENTIFIER() => 'perl',
);
$socket->send( $discover_packet->serialize(), 0, $br_addr )
    or die "Error sending:$!\n";
my $buf = '';
$socket->recv( $buf, 4096 ) or die "recvfrom() failed:$!";
my $resp = new Net::DHCP::Packet($buf);
print "Received response from: " . $socket->peerhost() . "\n";
print "Details:\n" . $resp->toString();
close($socket)
use IO::Socket::INET;
use Net::DHCP::Packet;
use Net::DHCP::Constants;
my $socket = IO::Socket::INET->new(
    Proto => 'udp',
    Broadcast => 1,
    LocalPort => '68',
) or die "Can't create socket: $@\n";
my $br_addr = sockaddr_in( '67', inet_aton('255.255.255.255') );
my $xid = int( rand(0xFFFFFFFF) );
my $chaddr = '0016cbb7c882';
my $discover_packet = Net::DHCP::Packet->new(
    Xid => $xid,
    Chaddr => $chaddr,
    Flags => 0x8000,
    DHO_DHCP_MESSAGE_TYPE() => DHCPDISCOVER(),
    DHO_HOST_NAME() => 'Perl Test Client',
    DHO_VENDOR_CLASS_IDENTIFIER() => 'perl',
);
$socket->send( $discover_packet->serialize(), 0, $br_addr )
    or die "Error sending:$!\n";
my $buf = '';
$socket->recv( $buf, 4096 ) or die "recvfrom() failed:$!";
my $resp = new Net::DHCP::Packet($buf);
my $request_packet = Net::DHCP::Packet->new(
    Xid => $xid,
    Chaddr => $chaddr,
    DHO_DHCP_MESSAGE_TYPE() => DHCPREQUEST(),
    DHO_VENDOR_CLASS_IDENTIFIER() => 'perl',
    DHO_HOST_NAME() => 'Perl Test Client',
    DHO_DHCP_REQUESTED_ADDRESS() => $resp->yiaddr(),
    DHO_DHCP_SERVER_IDENTIFIER() =>
        $resp->getOptionValue( DHO_DHCP_SERVER_IDENTIFIER() ),
);
$socket->send( $request_packet->serialize(), 0, $br_addr )
    or die "Error sending:$!\n";
$socket->recv( $buf, 4096 ) or die "recvfrom() failed:$!";
$resp = new Net::DHCP::Packet($buf);
print $resp->toString();
my $dhcp_server = $resp->getOptionValue( DHO_DHCP_SERVER_IDENTIFIER() );
close($socket);
my $socket = IO::Socket::INET->new(
    Proto => 'udp',
    LocalPort => '68',
    PeerPort => '67',
    PeerAddr => $dhcp_server,
) or die "Can't create socket: $@\n";
my $release_packet = Net::DHCP::Packet->new(
    Xid => $xid,
    Chaddr => $chaddr,
    DHO_DHCP_MESSAGE_TYPE() => DHCPRELEASE(),
);
$socket->send( $release_packet->serialize() )
    or die "Error sending:$!\n";
